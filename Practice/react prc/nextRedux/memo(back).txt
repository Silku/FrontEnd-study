const http = require('http')
const server = http.createServer((req,res)=>{
    res.end('hello')
})
server.listen(8080, ()=>{
    console.log('서버실행 ..')
});


[1] .express
app.get
app.post //생성 
app.delete
app.put  //전체수정
app.patch //부분수정
app.options //찔러보기(?)
app.head // 헤더만 가져오기(Headers/body)

※ swagger : api문서를 만들때 도와주는 툴
const express = require('express')

const app = express();

app.get('/', (req,res)=>{
    res.send('hello express')
})

app.listen(3300, ()=>{
    console.log('서버실행중...')
});

[1-2] rotuer 분리하기
불러올 파일 app.js에서 app.use()에서 '/post' 를 프리픽스로 붙여주면
post.js에서 route로 동작하는 코드를 '/'로 해줘도 정상적으로 불러올수 있음

파일 : app.js ..
const postRouter = require('./routes/post')
app.use('/post', postRouter);

파일 : routes/post.js
const express = require('express')
const router = express.Router();

router.post('/', (req,res)=>{
    res.json([
        {id:1 , content:'hello1'},
        {id:2 , content:'hello2'},
        {id:3 , content:'hello3'}
    ])  
})

router.delete('/', (req,res)=>{
    res.send({id:1})
})

module.exports = router;


[2] Sequelize / mySQL
mysql workbench
npm i sequelize sequelize-cli //js로 sql을 조작하게해주는 라이브러리
npm i mysql2   //node랑 mysql을 연결해주는 드라이버

npx sequelize init //시퀄라이즈 세팅 명령어
config/models/migrations/seeders 생성

config/config.js 설정
{
  "development": {
    "username": "root",
    "password": 0000,
    "database": "nodeboard",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "test": {
    "username": "root",
    "password": 0000,
    "database": "nodeboard",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "production": {
    "username": "root",
    "password": 0000,
    "database": "nodeboard",
    "host": "127.0.0.1",
    "dialect": "mysql"
  }
}

사용자 정보 저장할 user.js 작성 :
sequelize에서는 database table을 model로 부름

데이터 관계에 대한 로직은 associate()에 작성
Post.associate = (db) =>{
    db.Post.belongsTo(db.User)     // belongsTo (속해있다. 게시글은 유저에 속해있는거니까, belongsTo를 쓰면 나중에 db에 UserId, PostId등이 삽입됨)
    db.Post.belongsToMany(db.Hashtag); //belongsToMany(다대다 관계)
    db.Post.hasMany(db.Comment); ////hasMany(1:N관계, 여러개 가질수있다. 게시글에 여러 댓글이 달릴수있다.)
    db.Post.belongsToMany(db.User, {through : 'Like' ,as : 'Likers'});  

    db.User.belongsToMany(db.User, {through : 'Follow', as : 'Followers', foreignKey : 'FollowingId'});
    db.User.belongsToMany(db.User, {through : 'Follow', as : 'Followings', foreignKey : 'FollowerId'});
    //throught : N:N관계일경우 중간테이블의 이름,  
    //as : db.User면 중복이기때문에 Likers로 바꿔 저장되게끔
    //foreignKey : 컬럼내에서의 관계를 정하기 위해 사용
};

N : N 관계이면 중간테이블이 생긴다.


시퀄라이즈로 DB생성 
npx sequelize db:create
config.json에 int들어가면 안된다 전부 다 string으로만 설정!


// 아래 주석처리는  sequelize에서 자동으로 생성하는 형식 =>  
// belongsTo 는 단수형, belongsToMany는 복수형 등등..
db.Post.belongsTo(db.User) //post.addUser , post.getUser , post.setUser
db.Post.belongsToMany(db.Hashtag, {through : 'PostHashtag'});
db.Post.hasMany(db.Comment); //post.addComments, post.getComments
db.Post.hasMany(db.Image); //post.addImages , post.getImages
db.Post.belongsToMany(db.User, {through : 'Like' ,as : 'Likers'});  //post.addLikers, post.removeLikers


req/res.. 
헤더(상태 , 용량, 시간, 형식 쿠키 등)와
바디(데이터)로 구성되있음

status(상태) 
200 / 성공
300 / 리다이렉트
400 / 클라이언트 에러
500 / 서버에러 


CRUD 정리
========================================== 
create() 생성 
findOne(), findAll() 읽기

// 게시글 작성
router.post('/', isLoggedIn, async (req,res ,next)=>{ //Post/post
    try{
        const post = await Post.create({
            content : req.body.content,
            UserId : req.user.id,
        })
        
        const fullPost = await Post.findOne({
            where:{id:post.id},
            include : [{
                model : Image,
            },{
                model : Comment, 
                include : [{
                    model : User,//댓글 작성자
                    attributes : ['id', 'nickname'], 
                }]
            },{
                model : User, //게시글작성자
                attributes : ['id', 'nickname'],
            },{
                model : User, //좋아요 누른 사람
                as : 'Likers', //(model: post)에서 Likers라고 생성해준대로 가져와야됨
                attributes : ['id',]
            }]
        })
        res.status(201).json(fullPost);
    }catch(err){
        console.error(err)
        next(err)
    }
})



----------------
destroy() 삭제


router.delete('/:postId', isLoggedIn, async (req,res)=>{
    try{
        await Post.destroy({
            where:{id: req.params.postId},
            UserId : req.user.id, //내 아이디(조건)
        })
        res.status(200).json({PostId:req.params.postId})
    }catch(err){
        console.error(err)
    }
})

----------------
update() 수정 


router.patch('/nickname' , isLoggedIn, async(req,res)=>{
    try{
        await User.update({
            nickname:req.body.nickname,
        },{
            where : {id : req.user.id},
        })
        res.status(200).json({nickname:req.body.nickname})
    }catch(err){
        console.error(error)
        next(err)
    }
})



[3] cross origin resource sharing
브라우저에서 발생하는 문제 ..
서버-서버간의 통신에는 발생하지 않음.
ex )
브라우저(port :3060)
프론트서버(port :3060)
백엔드서버(port : 3065)
라고 할때 
Proxy방식 : 브라우저랑 프론트서버가 port가 같으므로 브라우저->프론트->백엔드서버로 요청/응답을 되돌려주는 방식으로 
cors를 피해갈수 있음

서버단에서 아래와 같이 설정
res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3060')
혹은 모두허용 : res.setHeader('Access-Control-Allow-Origin', '*')

또는 ..
app.js에 적용하면 더 쉬움..
npm i cors
app.use(cors(
    origin : '*', //모두허용
    credentials : true, //쿠키 허용
))


saga에서 비동기 요청 보낼때...
axios.post('/post', data, {
  withCredentials: true
})

withCredentials 뜻 : 서로 다른 도메인(크로스 도메인)에 요청을 보낼 때 요청에 credential 정보를 담아서 보낼 지를 결정
credential : 1.쿠키를 첨부해서 보내는 요청, 2.헤더에 Authorization 항목이 있는 요청

saga/index.js에서..
axios.defaults.withCredentials = true;
위처럼 해주면 항상 credential이 true로 가지게끔 설정해줄수있는데, 
node에서는 cors 전부허용이 안됨. (origin : '*')  =>
app.use(cors({
    origin: true, //또는 프론트서버 주소입력 origin: 'http://localhost:8080/' 
    credentials : true,
}))

** 요청이 get, delete 일경우 withCredentials는 항상 붙여줘야함
axios.get('/user', data, {
  withCredentials: true
})



[4] bcrypt
비밀번호 암호화 라이브러리
npm i bcrypt 

const hashedPassword = await bcrypt.hash(req.body.password, 10) 
//암호화하는 해시숫자 : 10~13정도 씀, 높을수록 강력하나 고사양 요구
await User.create({
        email : req.body.email,
        nickname : req.body.nickname,
        password : hashedPassword,
    })

[5]로그인 기능 구현
baseURL 설정
sagas/index.js...
import axios...
axios.defaults.baseURL = 'http://localhost:3065'
baseURL 설정해주면 axios로 처리하는 url에 기본값을 설정할 수있음.

ex)
function loginAPI(data){
    return axios.post('http://localhost:3065/user/login',data)
}

ex)baseURL 설정후
function loginAPI(data){
    return axios.post('/user/login',data)
}

[5-1] passport / passport-local 
https://www.npmjs.com/package/passport
로그인 관련 도구/ 구글,네이버,카카오 로그인등..
passport-local은 email로그인 등 지원
npm i  passport
npm i  passport-local

기본 코드
const passport = require('passport')
const local = require('./local')

module.exports = () =>{
    passport.serializeUser(()=>{

    })
    passport.deserializeUser(()=>{

    })
}

serializeUser() : 사용자 정보, 쿠키를 저장
deserializeUser() : 쿠카에 저장된 connect.sid값으로 부터 일치하는 사용자 정보를 찾고 httpRequest를 돌려줌 (로그인 이후 활동시(?))


[5-2] 세션/쿠키
npm i express-session
npm i cookie-parser



[5-3] dotenv
비밀 키 관리
npm i dotenv

const dotenv = require('dotenv')
dotenv.config();

비밀키 입력할곳 : process.env.비밀키


[6] 브라우저 관련...

[6-1] 브라우저 새로고침시 로그인이 풀리는 현상..
개발자도구-application-cookies에 프론트서버 url을 확인하면 connect.sid라는 쿠키/세션 값을 갖고있음.
즉 connect.sid값을 서버로 전달만 해주면 로그인이 된 상태가 될 수 있음.

**reducer든 node/routes든 실행순서에 주의하자..



[7] images처리
multipart...

npm i multer
파일 업로드 관련 모듈


// 이미지 업로드

//프론트
<input  type='file'  multiple style={{display:'none'}} ref={imageInput} onChange={onChangeImages}/>

const onChangeImages = useCallback((e)=>{
    console.log('images', e.target.files);
    const imageFormData = new FormData(); //formData를 쓰면 multipart형식으로 보낼수 있고 multer가 처리가능
    [].forEach.call(e.target.files, (f)=>{
        imageFormData.append('imageKeyValue', f)
        //append('키', 밸류) 여기의 키값이랑 multer의 upload.array('키') 키값이 일치해야함.
    })
    dispatch({
        type:UPLOAD_IMAGES_REQUEST,
        data:imageFormData,
    })
},[])

const upload = multer({
    // 하드디스크에 저장
    storage:multer.diskStorage({
        destination(req,file,done){
            done(null, 'uploads')
        },
        filename(req,file,done){ //사과.png
            const ext = path.extname(file.originalname); //확장자추출(.png)
            const basename = path.basename(file.originalname, ext) //사과
            done(null, basename + new Date().getTime() + ext) //사과2212300101.png
        }
    }),
    limits : {fileSize:20*1024*1024} //20mb
});
router.post('/images', isLoggedIn, upload.array('imageKeyValue'), async(req,res,next)=>{//POST, /post/images
    // upload.single , 하나올리기
    // upload.array , 여러개 올리기
    // upload.none , 이미지 안올림, 텍스트만 올린다 할때
    // upload.fields, 파일 인풋박스 자체가 여러개일떄

} )


// [TIPS]
PostForm.js 
함수안에 매개변수 넣는 식으로 쓸떄...
<Button onClick={onRemoveImage(i)}>삭제</Button>

//아래처럼 고차함수 활용하기
const onRemoveImage = useCallback((index) => () =>{
    dispatch({
        type:REMOVE_IMAGE,
        data:index,
    })
},[])


[8] node Hashtag

//post.js ... router.post('/') ...
const hashTags = req.body.content.match( /#[^\s#]+/g);
if(hashTags){
    // findOrCreate : db에 있으면 가져오고 없으면 생성
    // slice()로 #을 떼고 toLowerCase로 대소문자 구분없이 소문자로 치환
    const result = await Promise.all(hashTags.map((tag) => Hashtag.findOrCreate({
        //여기서 content는 db의 컬럼명..
        where : {content:tag.slice(1).toLowerCase()},
    })));
    await post.addHashtags(result.map((v) => v[0]))
}


trim() // 텍스트 양쪽 끝의 공백을 지워줌
ex ) text.trim();

[DB (mysql관련..)]
//DB 조작할떄는 await 붙인다고 보면 됨.
const posts = await Post.findAll({
    // where : {Userid : 1}

    order : [['createAt', 'DESC']], // 게시글 생성일, 내림차순(최신글)

    //offset으로 게시물 갯수 제어하는 방식은 잘 안쓴다. 누군가 게시글 추가/삭제했다면 꼬여버릴수 있기때문
    limit : 5, //불러올 게시글 제한
    offset : 0, //0 : 1~10번게시글...,  10 : 11~20번 게시글
})


