[1] next.js
SSR을 위한 react 프레임워크
npm i next@12


특징 : 
pages 폴더가 반드시 필요.
import React .. 없어도 상관없음.

1.components 추가하는법 
디렉토리에 components 폴더 추가 (pages와는 다르게 폴더명 달라도 상관없음)
//components 폴더
import PropTypes from 'prop-types';

const AppLayout = ({children}) => {
  return (
    <>
        <div>공통메뉴</div>
        {children}
    </>
  )
}

AppLayout.propTypes = {
    children : PropTypes.node.isRequired
    // 화면에 그릴수 있는 모든게 node, 'React의 node임' node.js의 node 아님!
};


2.pages/_app.js에 전역으로 사용할 내용을 작성,
특정 컴포넌트에서만 쓰는경우는 components/~~layout.js로 만드는 식으로

3. Header를 수정하고 싶을때, (title 등)
넥스트에서 제공하는 head 기능이 있다.
import Head from 'next/head'


[2] prop-types
npm i prop-types
타입스크립트면 prop-types가 필요없음. 자바스크립트면 필요
PropTypes는 부모로부터 전달받은 prop의 데이터 type을 검사한다. 자식 컴포넌트에서 명시해 놓은 데이터 타입과 부모로부터 넘겨받은 데이터 타입이 일치하지 않으면 콘솔에 에러 경고문이 띄워진다.

MyComponent.propTypes = {
  // 리액트 요소
  // <div>123</div> , <Component />
  menu: PropTypes.element,
  
  // 컴포넌트 함수가 반환할 수 있는 모든 것(비추)
  // <SomeComponent />, 123
  description: PropTypes.node,
  
  // Message 클래스로 생성된 모든 객체
  // new Messages() -> 참, new Car() -> 거짓
  message: PropTypes.instanceOf(Message),
  
  // 배열에 포함된 값 중에서 하나를 만족
  name: PropTypes.oneOf(["jake", "olivia"]),

  // 배열에 포함된 타입 중에서 하나를 만족
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string])

  // 특정 타입만 포함하는 배열
  // [1, 5, 7] -> 참, ['a', 'b'] -> 거짓
  ages: PropTypes.arrayOf(PropTypes.number),

  // 객체의 속성값 타입을 정의
  // {color: 'red', weight: 123} -> 참
  info: PropTypes.shape({
    color: PropTypes.string,
    weight: PropTypes.number
  })

  // 객체에서 모든 속성값의 타입이 같은 경우
  // {prop1: 123, prop2: 456}
  infos: PropTypes.objectOf(PropTypes.number)
}


[3] es-lint
npm i eslint -D
npm i eslint-plugin-import -D
eslint-plugin-react -D
eslint-plugin-react-hooks -D

협업시 코딩컨벤션을 일관되게 되도록 도와주는 도구


[4]antDesign / styled-components
npm i antd @ant-design/icons
비슷한 계열 : antDesign/bootStrap/Material-UI/Semantic UI

[5] 반응형 그리드
반응형 제작할때 모바일 -> 태블릿 -> 데스크탑 순으로 작업하는게 좋다. 

gutter : 그리드로 제작할때 컬럼 양쪽에 padding을 주는 단위
ex) gutter={16}  
=> 한컬럼에 양쪽으로 8px씩 padding 들어감

[5-1]. 앤트디 그리드시스템
https://ant.design/components/grid
xs : (모바일) screen < 576px
sm  : 태블릿
md : 작은 데스크탑
lg : 
xl : 
사이즈 n/24 기준으로 하는데 8/12/40 등등 가능함

[6] style을 적용할때..
<Button style={{margin:'10px'}}/>
이런식으로 스타일을 주면 문제점이.. Button안에 객체가 들어가 있기 때문에 리렌더링을 유발함.
useMemo(()=>{(margin:10)},[]) 하거나
stlyedComponent로 감싸주는게 좋음.


[7] 커스텀 훅
커스텀훅 사용 규칙 : 
1. 훅은 오직 리액트 함수 내에서만 사용되어야 한다. 일반적인 js 함수에서는 호출하면 안된다.
2. 리액트 함수 '최상위'에서 호출해야 한다.  -> 반복문, 조건문, 중첩된 함수 내에서 hook을 호출하면 안된다.

[8] Next-Redux
일반 redux다루는 법이랑 다름.
directory/store/configureStore.js
npm i next-redux-wrapper react-redux

기존 redux는 _app.js에서 
return 최상단에 아래처럼 감싸주는데 
<Provider store={store}></Provider>
next 6버전에서는 자동으로 provider로 감싸주기때문에 따로 쓰면 오히려 중복으로 에러가난다.

[8-1] redux필요한 이유 : 
데이터 관리를 중앙에서 용이하게 하기 위함
React - ContextAPI, 
Redux , 
Mobx, (redux보다 생산성이 좋다.)
Apollo GraphQ

[8-2] redux 개념
데이터를 조회,수정,삭제 등등 할떄 
action -> dispatch 하는 원리가 핵심
reducer에서 switch문으로 어떻게 바뀔건지 로직 작성

[8-3] redux의 불변성
switch(action.type){
  case 'ACTION_ONE'
    return{
      ...state,
      name : action.data,
    }
}

js에서 새로 만든 객체는 항상 false인데 대입관계가되면 true가 됨.
{} === {} // false
const a = {};
const b = a;
a === b //true

위의 switch문 처럼
...spread 문법을 쓰면 ...spread를 참조하는 새로운 객체를 생성하는것이 가능해짐.
따라서 메모리 활용면에서 유연하고 새로운 객체를 생성한것이기 떄문에 히스토리 관리가 수월해짐.
예를 들어 next라는 객체가 새로 생성되었어도 
prev라는 객체 또한 메모리상에 남아있기때문에 prev로 돌아가는것이 가능. 
일반적인 b=a처럼 대입관계였다면 불가능.

** : 적용방법

** props로 받을 필요가 없기때문에 props로 받은것들 지우고, propTypes도 필요없다.
** 사용할 개별 페이지에 -
       import { useDispatch } from 'react-redux'
      useDispatch({id,pw}) 처럼 사용

** reducer/index.js에서 -
    import { HYDRATE } from "next-redux-wrapper"
    
    아래 스위치 문에서 HYDRATE는 아래와 같이 적용
    switch(action.type){
    case HYDRATE : 
    console.log('HYDRATE' , action)
        return {...state, ...action.payload}

HYDRATE는 무엇? : 
HYDRATE가 생긴 이유는 getInitialProps가 요즘 거의 안쓰이고
getStaticProps, getServerSideProps 두개로 바껴서 SSR이 기존과 완전히 달라졌기 떄문.


[8-4] redux-devtools-extension
npm i redux-devtools-extension

[8-5] reducer 분할
combineReducers() //redux
코드가 분할된만큼 switch문에서 depth 낮춰줘야함.



[9] jsx에서 배열 써서 엘레멘트 생성할떄는 key값 항상 필요!!
ex) PostCard.js
//post를 props로 받아오는 상황
        <Card
            cover={post.Images[0] && <PostImages images={post.Images}/>}
            actions={[
                <RetweetOutlined key="reply"/>,
                <HeartOutlined key="heart"/>,
                <MessageOutLined key="comment"/>,
                <Popover>
                    <EllipsisOutlined/>
                </Popover>
            ]}
        >

[10] react 토글버튼
  const onToggleLike = useCallback(()=>{
      setLiked((prev) =>!prev);
  },[])

===기타 상식 
CSR/ SSR 관련 : 
1. SSR할떄, 
브라우저 / 프론트서버 / 백엔드 서버 이렇게 있다고 치면
프론트서버에서 백엔드서버 요청할때 도메인이 다르면 CORS설정 해줘야 한다. 

2.CSR에서 요청하면, 프론트 서버는 html/js로  로딩을 띄우고 데이터 없이 render. => 백엔드에서 데이터를 받아와서 브라우저로 데이터를 채워줌
SSR에서 요청하면 프론트 서버가 백엔드 서버로 요청하고 응답을 프론트서버에서 html/js 합쳐서 브라우저로 넘겨줌

SQL/ noSQL 관련 : 
회원정보/구매내역 이런 관계가 있다하면 무조건 SQL
정해지지 않은 데이터가 무작위로 들어올때 noSQL 
대부분의 서비스의 경우 SQL이 좋다


<a>관련 : 
target="_blank"는 보안에 취약하다.
rel='noopener noreferrer' 꼭 써줘야한다. 

noopener 지정하면, 링크된 페이지에서 window.opener을 사용해서 링크를 건 페이지를 참조(reference)할 수 없게 됨.
링크된 페이지와 링크를 건 페이지는 별개의 프로세스로 취급되기 때문에 서로 연결되어 퍼포먼스가 떨어지는 일도 없게 됨.

noreferrer(노리퍼러)를 지정하면 다른 페이지로 이동할 때,
링크를 건 페이지의 주소 등의 정보를 브라우저가 Referer: HTTP 헤더로 리퍼러(referer 또는 referrer)로서 송신하지 않음.



[?.] optional chaining 연산자 :   
왼쪽이 null이 아니면 오른쪽값 보여줌
//?. 없이 빈값이 들어오면 원래는 에러메세지를 뱉는다. 그러나 ?.를 쓰면 undefined를 남겨준다.
//사용법 : 값이 안들어와서 에러날때 임시로 가리는 용도로 사용할수 있다.

user ?. user.name
//user가 null이면  user.name이 표시되지 않음
//그리고 값이 없을 떄 에러를 남기는 대신 undefined를 남겨줌

|| 와 ?? 의 차이
||
0, false, undefined같은 boolean으로 'false인 값을 전부 검사'한다.
??
undefined, null같은 nullish만 검사하는 연산자

[??] nullish coalescing 연산자
//사용법 :  데이터 가져오는데 지연시간 때문에 다른걸 띄우고 싶을때 사용
user ?? '로딩중'