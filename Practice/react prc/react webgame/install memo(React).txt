[1] Webpack . 시작하기.
-------------------------------------------------------------
1. 시작하기
npm init  => package.json 생성.
npm i react react-dom  //react , react-dom 설치
npm i -D webpack webpack-cli //웹팩 및 웹팩cli 설치, -D는 개발용("devDependencies")
*메모사항 : ******** 
    -D 는 개발용으로 쓰인다는것을 의미함.
    package.json에도 아래처럼 webpack이 devDependencies라고 따로 등록됨.
  "devDependencies": {
    "webpack": "^5.74.0",
    "webpack-cli": "^4.10.0"
  }
*********

2. webpack.config.js 파일 생성 후 아래 코드 추가
// (webpack.config.js 거의 기본형)
// entry, output, module, plugins + @ 일단 이정도로 알아두기

const path = require('path');

module.exports  ={
    entry:{

    },
    module:{

    },
    plugins:[ ],
    output:{
      path: path.join(__dirnamem, 'dist'),
    },
}

2-1. path에 대한 설명
const path = require('path');

output:{
  path: path.join(__dirname, 'dist'),
},

node의 path를 불러온다음 path.join(__dirname, 'dist'), 이런식으로 해주면
해당 디렉토리에 'dist' 폴더에 접근하게끔 해주는것임.
이렇게 쓰지 않을경우, C://progamfiles.... 다 찾아서 들어가는 엄청 복잡한 경로를 직접 세팅해줘야함.



3.jsx 파일 생성 후 아래코드 추가
const React = require('react')
const ReactDOM = require('react-dom')





[2] 빌드하기
1.package.json에서 스크립트 부분을 아래와 같이 지정
  "scripts": {
    "dev": "webpack"
  },

2.터미널에서 아래와 같이 실행
npm run dev
npx webpack

==> webpack.config.js 에서 output 설정해준것과 같이 dist/app.js 가 생성됨

3.babel이 있어야 jsx파일을 읽을 수 있고 babel에서 jsx를 읽을 수 있도록 설정해야한다.
npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader
아래처럼 나눠서 설치해도 됨
npm i -D @babel/core            //기본 바벨, 최신문법
npm i @babel/preset-env       //바벨을 환경에 맞게 바꿔줌
npm i @babel/preset-react     // react -> jsx를 읽는 역할 
npm i babel-loader                //바벨과 웹팩을 연결하는 역할


babel/preset-env 설정 :: 브라우저 지원 관련 참조 링크
https://github.com/browserslist/browserslist

웹팩 공식문서
https://webpack.js.org/concepts/



[3] 웹팩 4버전 변경점 관련... webpack dev server 등
// 연습파일 : NumberBaseBall
// 제일 중요한거. 
/**
react-refresh, @pmmmwh 둘의 버전 차이라던지 webpack cli 버전이라던지 에러를 유발하는 상황이 너무 많음.
짜증나니 지금 당장은 이렇게 버전 맞춰서 사용.

"@pmmmwh/react-refresh-webpack-plugin": "^0.5.1",
"react-refresh": "^0.10.0",
"webpack": "^5.74.0",
"webpack-cli": "^4.10.0",
"webpack-dev-server": "^4.3.1"

 **/ 

** webpack-cli가 3 -> 4에서 변경점이 있으므로 알아둘것.**

npm i react-refresh @pmmmwh/react-refresh-webpack-plugin -D
npm i webpack-dev-server -D


기존 package.json
scripts : {
  "dev" : "webpack-dev-server --hot"
}

변경점 ==> 
scripts : {
  "dev" : "webpack serve --env development"
}


기존 webpack.config.js
module 에서 loader : 'babel-loader'.....
options : {
    plugins:[
      'react-hot-loader/babel',
  ],
}

변경점 ==> 
plugins:[
    'react-refesh/babel',
],

새로 추가 ==>
devServer:{
    publicPath: '/dist',
    hot:true
}


[4]controlled input & uncontrolled input
참고 사이트 : https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/

-- controlled input 쓸때 가능한것
instant field validation = 비밀번호 조건
conditionally disabling submit input = 비밀번호 8자리 입력해야되는데 4자리 입력한 경우 submit disable 시킴
enforcing input format = 비밀번호 조건 강제
several inputs for one piece of data = setState로 여러 input data를 컨트롤 하게할 경우
dynamic inputs = 비밀번호 잘못썼을때 빨간테두리 등


[5] React 배열과 key

html에 대략 이런 배열이 있으면 이렇게 반복문 사용가능.

<ul>
  {['사과', '바나나','귤', '포도'].map((v)=>{
      return (
          <li>{v}</li>
      )
  })} 


여기서 map() 다음 중괄호를 지워서도 사용이 가능함.
<ul>
  {['사과', '바나나',  '귤', '포도'].map((v)=>
          <li>{v}</li>
  )}
</ul>

다음처럼 '절대 쓰지말것' ... key값 정하기 까다로워서 i값을 줘버리면 성능최적화에 안좋으니 다음처럼 쓰지마라 .. 
아래처럼 바뀌면 뭐가 바꼈는지 리액트가 인식을 못할수 있다.
근데 리액트 반복문을 쓸떄는 key값이 중요한데
key값은 고유한값을 줘야되고 정하는게 좀 골치아픈 작업이다.
<ul>
  {['사과', '바나나',  '귤', '포도'].map((v,i)=>
          <li key={i}>{v,i}</li>
  )}
</ul>


[6] React dev tools
...

실제 서비스할때 : webpack.config.js 에서,,
아래 두개 붙여주면됨

production.env.NODE_ENV = 'production'

module.exports = {
mode: ' production'
}

[7] react Memo.
class 형태로 쓸때는 pureComponent, 함수컴포넌트(hooks)로 쓸때는 Memo()로 감싸주는 형태로 쓰면됨.
- 자식 컴포넌트가 언제 리렌더링 되나 ? 
=> state가 바뀌었을때, props가 바뀌었을때, 부모컴포넌트가 리렌더링 됬을때.
=> memo는 부모컴포넌트가 리렌더링될때 자식컴포넌트가 리렌더링되는걸 막아주는 역할.


[8] useRef
useRef 쓰는 경우 : dom에 직접 접근이 필요할때, hooks에서 this속성에 접근할때
!!!!useRef쓰는데는 current 항상붙음. !!!!!
useRef는 렌더링을 일으키지 않음, 값이 바뀌긴 하지만 화면에 영향을 주지 않는것에 사용.